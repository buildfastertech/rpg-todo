---
alwaysApply: false
---

# Supabase Standards for RPG Todo

## Core Principles

1. **Row Level Security (RLS)** - Always enable RLS on tables
2. **Type Safety** - Generate TypeScript types from database
3. **Secure Patterns** - Never expose service keys in client
4. **Efficient Queries** - Use select specific columns, indexes
5. **Real-time** - Leverage real-time subscriptions where needed

## Setup

### Environment Variables

```bash
# server/.env
SUPABASE_URL=https://your-project.supabase.co
SUPABASE_ANON_KEY=your-anon-key
SUPABASE_SERVICE_KEY=your-service-key # SERVER ONLY

# client/.env
VITE_SUPABASE_URL=https://your-project.supabase.co
VITE_SUPABASE_ANON_KEY=your-anon-key # Safe for client
```

### Client Initialization

```typescript
// server/src/config/supabase.ts
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = process.env.SUPABASE_URL!;
const supabaseKey = process.env.SUPABASE_SERVICE_KEY!; // Service key for server

export const supabase = createClient(supabaseUrl, supabaseKey);
```

```typescript
// client/src/lib/supabase.ts
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = import.meta.env.VITE_SUPABASE_URL!;
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY!; // Anon key for client

export const supabase = createClient(supabaseUrl, supabaseAnonKey);
```

## Database Schema

### SQL Schema Creation

```sql
-- Enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Users table (simplified - XP calculated dynamically from points_ledger)
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  username VARCHAR(50) UNIQUE NOT NULL,
  email VARCHAR(255) UNIQUE NOT NULL,
  password VARCHAR(255) NOT NULL,
  level INTEGER DEFAULT 1,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Tasks table
CREATE TABLE tasks (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  title VARCHAR(200) NOT NULL,
  description TEXT,
  due_date TIMESTAMPTZ NOT NULL,
  status VARCHAR(20) DEFAULT 'open' CHECK (status IN ('open', 'completed', 'archived')),
  priority VARCHAR(20) NOT NULL CHECK (priority IN ('Low', 'Medium', 'High', 'Urgent')),
  xp_value INTEGER NOT NULL,
  category VARCHAR(50),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Achievements table (master list of all achievements)
CREATE TABLE achievements (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  achievement_name VARCHAR(100) NOT NULL,
  achievement_description VARCHAR(100) NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Achievement_user join table (tracks which users have which achievements)
CREATE TABLE achievement_user (
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  achievement_id UUID NOT NULL REFERENCES achievements(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  PRIMARY KEY (user_id, achievement_id)
);

-- Custom labels table (linked to tasks, not users)
CREATE TABLE custom_labels (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  task_id UUID NOT NULL REFERENCES tasks(id) ON DELETE CASCADE,
  label_name VARCHAR(50) NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(task_id, label_name)
);

-- Points ledger table (transaction log for all XP awards)
CREATE TABLE points_ledger (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  task_id UUID REFERENCES tasks(id) ON DELETE SET NULL,
  description TEXT,
  xp_value INTEGER NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_tasks_user_id ON tasks(user_id);
CREATE INDEX idx_tasks_status ON tasks(status);
CREATE INDEX idx_tasks_due_date ON tasks(due_date);
CREATE INDEX idx_tasks_priority ON tasks(priority);
CREATE INDEX idx_tasks_user_status_due ON tasks(user_id, status, due_date);
CREATE INDEX idx_achievement_user_user_id ON achievement_user(user_id);
CREATE INDEX idx_achievement_user_achievement_id ON achievement_user(achievement_id);
CREATE INDEX idx_custom_labels_task_id ON custom_labels(task_id);
CREATE INDEX idx_points_ledger_user_id ON points_ledger(user_id);
CREATE INDEX idx_points_ledger_task_id ON points_ledger(task_id);

-- Updated_at trigger function
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Apply trigger to tables
CREATE TRIGGER update_users_updated_at BEFORE UPDATE ON users
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_tasks_updated_at BEFORE UPDATE ON tasks
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

### Row Level Security (RLS) Policies

```sql
-- Enable RLS on all tables
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE tasks ENABLE ROW LEVEL SECURITY;
ALTER TABLE achievements ENABLE ROW LEVEL SECURITY;
ALTER TABLE achievement_user ENABLE ROW LEVEL SECURITY;
ALTER TABLE custom_labels ENABLE ROW LEVEL SECURITY;
ALTER TABLE points_ledger ENABLE ROW LEVEL SECURITY;

-- Users policies
CREATE POLICY "Users can view own profile"
  ON users FOR SELECT
  USING (auth.uid() = id);

CREATE POLICY "Users can update own profile"
  ON users FOR UPDATE
  USING (auth.uid() = id);

-- Tasks policies
CREATE POLICY "Users can view own tasks"
  ON tasks FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can create own tasks"
  ON tasks FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own tasks"
  ON tasks FOR UPDATE
  USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own tasks"
  ON tasks FOR DELETE
  USING (auth.uid() = user_id);

-- Achievements policies (public read for achievement definitions)
CREATE POLICY "Anyone can view achievements"
  ON achievements FOR SELECT
  USING (true);

-- Achievement_user policies
CREATE POLICY "Users can view own unlocked achievements"
  ON achievement_user FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can unlock own achievements"
  ON achievement_user FOR INSERT
  WITH CHECK (auth.uid() = user_id);

-- Custom labels policies (linked to tasks)
CREATE POLICY "Users can view labels on own tasks"
  ON custom_labels FOR SELECT
  USING (EXISTS (
    SELECT 1 FROM tasks WHERE tasks.id = custom_labels.task_id AND tasks.user_id = auth.uid()
  ));

CREATE POLICY "Users can add labels to own tasks"
  ON custom_labels FOR INSERT
  WITH CHECK (EXISTS (
    SELECT 1 FROM tasks WHERE tasks.id = custom_labels.task_id AND tasks.user_id = auth.uid()
  ));

CREATE POLICY "Users can update labels on own tasks"
  ON custom_labels FOR UPDATE
  USING (EXISTS (
    SELECT 1 FROM tasks WHERE tasks.id = custom_labels.task_id AND tasks.user_id = auth.uid()
  ));

CREATE POLICY "Users can delete labels from own tasks"
  ON custom_labels FOR DELETE
  USING (EXISTS (
    SELECT 1 FROM tasks WHERE tasks.id = custom_labels.task_id AND tasks.user_id = auth.uid()
  ));

-- Points ledger policies
CREATE POLICY "Users can view own XP transactions"
  ON points_ledger FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can create own XP transactions"
  ON points_ledger FOR INSERT
  WITH CHECK (auth.uid() = user_id);
```

### Database Functions

```sql
-- Function to get user's total XP (sum from points_ledger)
CREATE OR REPLACE FUNCTION get_user_total_xp(p_user_id UUID)
RETURNS INTEGER AS $$
  SELECT COALESCE(SUM(xp_value), 0)::INTEGER 
  FROM points_ledger 
  WHERE user_id = p_user_id;
$$ LANGUAGE sql SECURITY DEFINER;

-- Function to calculate level from XP
CREATE OR REPLACE FUNCTION calculate_level_from_xp(xp INTEGER)
RETURNS INTEGER AS $$
DECLARE
  level INTEGER := 1;
  thresholds INTEGER[] := ARRAY[0, 100, 250, 500, 1000, 2000, 3500, 5500, 8000, 11000, 14500];
BEGIN
  FOR i IN REVERSE array_upper(thresholds, 1)..1 LOOP
    IF xp >= thresholds[i] THEN
      RETURN i;
    END IF;
  END LOOP;
  RETURN 1;
END;
$$ LANGUAGE plpgsql IMMUTABLE SECURITY DEFINER;

-- Function to get completed task count for achievements
CREATE OR REPLACE FUNCTION get_completed_task_count(p_user_id UUID)
RETURNS INTEGER AS $$
  SELECT COUNT(*)::INTEGER 
  FROM tasks 
  WHERE user_id = p_user_id AND status = 'completed';
$$ LANGUAGE sql SECURITY DEFINER;

-- Function to get urgent tasks for the week
CREATE OR REPLACE FUNCTION get_urgent_tasks_this_week(p_user_id UUID)
RETURNS SETOF tasks AS $$
  SELECT * FROM tasks
  WHERE user_id = p_user_id
    AND priority = 'Urgent'
    AND status = 'open'
    AND due_date >= date_trunc('week', NOW())
    AND due_date < date_trunc('week', NOW()) + INTERVAL '1 week';
$$ LANGUAGE sql SECURITY DEFINER;

-- Function to award XP and update level
CREATE OR REPLACE FUNCTION award_xp(
  p_user_id UUID,
  p_xp_value INTEGER,
  p_description TEXT,
  p_task_id UUID DEFAULT NULL
)
RETURNS TABLE(new_total_xp INTEGER, new_level INTEGER, leveled_up BOOLEAN) AS $$
DECLARE
  v_old_level INTEGER;
  v_new_total_xp INTEGER;
  v_new_level INTEGER;
BEGIN
  -- Get current level
  SELECT level INTO v_old_level FROM users WHERE id = p_user_id;
  
  -- Create ledger entry
  INSERT INTO points_ledger (user_id, task_id, description, xp_value)
  VALUES (p_user_id, p_task_id, p_description, p_xp_value);
  
  -- Calculate new total XP
  v_new_total_xp := get_user_total_xp(p_user_id);
  
  -- Calculate new level
  v_new_level := calculate_level_from_xp(v_new_total_xp);
  
  -- Update user level if changed
  IF v_new_level != v_old_level THEN
    UPDATE users SET level = v_new_level WHERE id = p_user_id;
  END IF;
  
  RETURN QUERY SELECT v_new_total_xp, v_new_level, (v_new_level > v_old_level);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

## Query Patterns

### Basic CRUD Operations

```typescript
// CREATE
const { data, error } = await supabase
  .from('tasks')
  .insert({
    user_id: userId,
    title: 'New Task',
    description: 'Description',
    due_date: new Date().toISOString(),
    priority: 'Medium',
    xp_value: 25,
    status: 'open'
  })
  .select()
  .single();

// READ (with filtering)
const { data, error } = await supabase
  .from('tasks')
  .select('*')
  .eq('user_id', userId)
  .eq('status', 'open')
  .order('due_date', { ascending: true })
  .order('priority', { ascending: false });

// READ (with pagination)
const { data, error } = await supabase
  .from('tasks')
  .select('*', { count: 'exact' })
  .eq('user_id', userId)
  .range(0, 24); // First 25 items

// UPDATE
const { data, error } = await supabase
  .from('tasks')
  .update({ status: 'completed' })
  .eq('id', taskId)
  .eq('user_id', userId)
  .select()
  .single();

// DELETE
const { error } = await supabase
  .from('tasks')
  .delete()
  .eq('id', taskId)
  .eq('user_id', userId);
```

### Complex Queries

```typescript
// Get tasks with counts
const { data, error } = await supabase
  .from('tasks')
  .select('*, custom_labels!left(label_name)')
  .eq('user_id', userId);

// Call database function
const { data, error } = await supabase
  .rpc('increment_completed_tasks', { user_id: userId });

// Get count only
const { count, error } = await supabase
  .from('tasks')
  .select('*', { count: 'exact', head: true })
  .eq('user_id', userId)
  .eq('status', 'completed');
```

## Authentication

### Sign Up

```typescript
const { data, error } = await supabase.auth.signUp({
  email: 'user@example.com',
  password: 'securepassword',
  options: {
    data: {
      username: 'username',
    }
  }
});

// After signup, create user profile
if (data.user) {
  await supabase
    .from('users')
    .insert({
      id: data.user.id,
      email: data.user.email,
      username: username,
      level: 1
    });
  
  // Award registration XP via ledger
  await supabase.rpc('award_xp', {
    p_user_id: data.user.id,
    p_xp_value: 5,
    p_description: 'Registration bonus',
    p_task_id: null
  });
}
```

### Sign In

```typescript
const { data, error } = await supabase.auth.signInWithPassword({
  email: 'user@example.com',
  password: 'password',
});

// Award daily login XP (check if already awarded today)
if (data.user) {
  // Check if user already got login XP today
  const today = new Date().toISOString().split('T')[0];
  const { data: todayLogin } = await supabase
    .from('points_ledger')
    .select('id')
    .eq('user_id', data.user.id)
    .eq('description', 'Daily login')
    .gte('created_at', today)
    .maybeSingle();
  
  if (!todayLogin) {
    await supabase.rpc('award_xp', {
      p_user_id: data.user.id,
      p_xp_value: 2,
      p_description: 'Daily login',
      p_task_id: null
    });
  }
}
```

### Get Current User

```typescript
const { data: { user } } = await supabase.auth.getUser();
```

### Sign Out

```typescript
const { error } = await supabase.auth.signOut();
```

### Auth State Change (Client)

```typescript
supabase.auth.onAuthStateChange((event, session) => {
  if (event === 'SIGNED_IN') {
    // User signed in
  } else if (event === 'SIGNED_OUT') {
    // User signed out
  }
});
```

## Real-time Subscriptions

```typescript
// Subscribe to task changes
const channel = supabase
  .channel('tasks-changes')
  .on(
    'postgres_changes',
    {
      event: '*',
      schema: 'public',
      table: 'tasks',
      filter: `user_id=eq.${userId}`
    },
    (payload) => {
      console.log('Change received!', payload);
      // Update local state
    }
  )
  .subscribe();

// Unsubscribe when component unmounts
return () => {
  supabase.removeChannel(channel);
};
```

## TypeScript Types

Generate types from database schema:

```bash
# Install Supabase CLI
npm install -g supabase

# Generate types
supabase gen types typescript --project-id your-project-id > types/supabase.ts
```

```typescript
// types/supabase.ts (auto-generated)
export type Database = {
  public: {
    Tables: {
      tasks: {
        Row: {
          id: string;
          user_id: string;
          title: string;
          // ...
        };
        Insert: {
          id?: string;
          user_id: string;
          title: string;
          // ...
        };
        Update: {
          id?: string;
          // all fields optional
        };
      };
    };
  };
};

// Use with client
import { Database } from './types/supabase';
const supabase = createClient<Database>(url, key);
```

## Error Handling

```typescript
const { data, error } = await supabase
  .from('tasks')
  .select('*')
  .eq('user_id', userId);

if (error) {
  // Handle specific errors
  if (error.code === 'PGRST116') {
    // No rows returned
  }
  console.error('Supabase error:', error.message);
  throw new Error('Failed to fetch tasks');
}

return data;
```

## Best Practices

1. **Always enable RLS** - Protect data at database level
2. **Use service key server-side only** - Never expose in client
3. **Select specific columns** - Don't use `select('*')` in production
4. **Use indexes** - Add indexes on frequently queried columns
5. **Batch operations** - Use `.insert([])` for multiple rows
6. **Type safety** - Generate and use TypeScript types
7. **Handle errors** - Always check for errors
8. **Use transactions** - For related operations
9. **Optimize queries** - Use `.explain()` to analyze query performance
10. **Clean up subscriptions** - Unsubscribe when done

## Security Checklist

- ✅ RLS enabled on all tables
- ✅ Policies restrict access to user's own data
- ✅ Service key only used server-side
- ✅ Input validation before database operations
- ✅ Passwords hashed (use Supabase Auth)
- ✅ No sensitive data in client code
- ✅ Database functions use SECURITY DEFINER carefully
- ✅ Regular backups enabled
- ✅ Monitor for suspicious activity

## Common Patterns for RPG Todo

### Award XP and Check Level (Using Ledger)

```typescript
const awardXPAndCheckLevel = async (
  userId: string,
  xpAmount: number,
  description: string,
  taskId?: string
) => {
  // Use database function to award XP and update level
  const { data, error } = await supabase
    .rpc('award_xp', {
      p_user_id: userId,
      p_xp_value: xpAmount,
      p_description: description,
      p_task_id: taskId || null
    });

  if (error) {
    throw new Error(`Failed to award XP: ${error.message}`);
  }

  // data[0] contains: new_total_xp, new_level, leveled_up
  return {
    newXP: data[0].new_total_xp,
    newLevel: data[0].new_level,
    leveledUp: data[0].leveled_up
  };
};
```

### Get User's Total XP

```typescript
const getUserTotalXP = async (userId: string): Promise<number> => {
  const { data, error } = await supabase
    .rpc('get_user_total_xp', { p_user_id: userId });

  if (error) {
    throw new Error(`Failed to get XP: ${error.message}`);
  }

  return data;
};
```

### Get User's XP History

```typescript
const getUserXPHistory = async (userId: string) => {
  const { data, error } = await supabase
    .from('points_ledger')
    .select('*')
    .eq('user_id', userId)
    .order('created_at', { ascending: false });

  if (error) {
    throw new Error(`Failed to get XP history: ${error.message}`);
  }

  return data;
};
```

### Check and Award Achievement

```typescript
const checkAndAwardAchievement = async (
  userId: string,
  achievementId: string
) => {
  // Check if already unlocked
  const { data: existing } = await supabase
    .from('achievement_user')
    .select('*')
    .eq('user_id', userId)
    .eq('achievement_id', achievementId)
    .maybeSingle();

  if (existing) {
    return null; // Already unlocked
  }

  // Award achievement
  const { data, error } = await supabase
    .from('achievement_user')
    .insert({
      user_id: userId,
      achievement_id: achievementId,
    })
    .select()
    .single();

  if (error) {
    throw new Error(`Failed to award achievement: ${error.message}`);
  }

  return data;
};
```

### Get User's Unlocked Achievements

```typescript
const getUserAchievements = async (userId: string) => {
  const { data, error } = await supabase
    .from('achievement_user')
    .select(`
      *,
      achievement:achievements(*)
    `)
    .eq('user_id', userId);

  if (error) {
    throw new Error(`Failed to get achievements: ${error.message}`);
  }

  return data;
};
```

### Add Label to Task

```typescript
const addLabelToTask = async (taskId: string, labelName: string) => {
  const { data, error } = await supabase
    .from('custom_labels')
    .insert({
      task_id: taskId,
      label_name: labelName,
    })
    .select()
    .single();

  if (error) {
    throw new Error(`Failed to add label: ${error.message}`);
  }

  return data;
};
```

### Get Task with Labels

```typescript
const getTaskWithLabels = async (taskId: string, userId: string) => {
  const { data, error } = await supabase
    .from('tasks')
    .select(`
      *,
      labels:custom_labels(*)
    `)
    .eq('id', taskId)
    .eq('user_id', userId)
    .single();

  if (error) {
    throw new Error(`Failed to get task: ${error.message}`);
  }

  return data;
};
```
