---
alwaysApply: false
---

# React Standards for RPG Todo

## Core Principles

1. **Functional Components Only** - No class components
2. **TypeScript** - Use TypeScript for type safety
3. **Component Composition** - Break down into small, reusable components
4. **Custom Hooks** - Extract reusable logic into custom hooks
5. **Proper State Management** - Use appropriate React hooks for state

## File Structure

```
client/src/
├── components/
│   ├── layout/
│   │   ├── Header.tsx
│   │   ├── Navigation.tsx
│   │   └── Layout.tsx
│   ├── tasks/
│   │   ├── TaskList.tsx
│   │   ├── TaskItem.tsx
│   │   ├── TaskForm.tsx
│   │   └── TaskFilters.tsx
│   ├── profile/
│   │   ├── ProfileCard.tsx
│   │   ├── ProfileEditor.tsx
│   │   └── StatsDisplay.tsx
│   ├── achievements/
│   │   ├── AchievementList.tsx
│   │   ├── AchievementCard.tsx
│   │   └── AchievementProgress.tsx
│   └── common/
│       ├── XPBar.tsx
│       ├── LevelDisplay.tsx
│       └── PriorityBadge.tsx
├── pages/
│   ├── Dashboard.tsx
│   ├── Profile.tsx
│   ├── Achievements.tsx
│   └── Archive.tsx
├── hooks/
│   ├── useAuth.ts
│   ├── useTasks.ts
│   ├── useXP.ts
│   └── useAchievements.ts
├── services/
│   ├── api.ts
│   ├── auth.service.ts
│   ├── task.service.ts
│   └── achievement.service.ts
├── types/
│   ├── user.types.ts
│   ├── task.types.ts
│   └── achievement.types.ts
└── utils/
    ├── xpCalculator.ts
    └── dateFormatter.ts
```

## Component Patterns

### Functional Component with TypeScript

```typescript
import { FC } from 'react';

interface TaskItemProps {
  task: Task;
  onComplete: (taskId: string) => void;
  onEdit: (taskId: string) => void;
  onDelete: (taskId: string) => void;
}

export const TaskItem: FC<TaskItemProps> = ({ task, onComplete, onEdit, onDelete }) => {
  return (
    <div className="task-item">
      <h3>{task.title}</h3>
      <p>{task.description}</p>
      {/* Component content */}
    </div>
  );
};
```

### Custom Hooks

Extract reusable logic into custom hooks:

```typescript
// hooks/useTasks.ts
import { useState, useEffect } from 'react';
import { taskService } from '../services/task.service';
import type { Task } from '../types/task.types';

export const useTasks = (userId: string) => {
  const [tasks, setTasks] = useState<Task[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchTasks = async () => {
      try {
        setLoading(true);
        const data = await taskService.getTasks(userId);
        setTasks(data);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Failed to fetch tasks');
      } finally {
        setLoading(false);
      }
    };

    fetchTasks();
  }, [userId]);

  const addTask = async (task: Omit<Task, 'id'>) => {
    const newTask = await taskService.createTask(task);
    setTasks(prev => [...prev, newTask]);
  };

  const completeTask = async (taskId: string) => {
    await taskService.completeTask(taskId);
    setTasks(prev => prev.map(t => 
      t.id === taskId ? { ...t, status: 'completed' } : t
    ));
  };

  return { tasks, loading, error, addTask, completeTask };
};
```

### State Management

**Local State** - Use `useState` for component-specific state:
```typescript
const [isOpen, setIsOpen] = useState(false);
const [formData, setFormData] = useState({ title: '', description: '' });
```

**Side Effects** - Use `useEffect` for data fetching and subscriptions:
```typescript
useEffect(() => {
  const fetchData = async () => {
    const data = await api.getData();
    setData(data);
  };
  
  fetchData();
}, [dependency]);
```

**Context** - Use `useContext` for global state (user, theme):
```typescript
// contexts/AuthContext.tsx
import { createContext, useContext, useState, FC, ReactNode } from 'react';

interface AuthContextType {
  user: User | null;
  login: (email: string, password: string) => Promise<void>;
  logout: () => void;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider: FC<{ children: ReactNode }> = ({ children }) => {
  const [user, setUser] = useState<User | null>(null);

  const login = async (email: string, password: string) => {
    // Login logic
  };

  const logout = () => {
    setUser(null);
  };

  return (
    <AuthContext.Provider value={{ user, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  return context;
};
```

## Type Definitions

Create comprehensive TypeScript types:

```typescript
// types/task.types.ts
export enum TaskPriority {
  Low = 'Low',
  Medium = 'Medium',
  High = 'High',
  Urgent = 'Urgent'
}

export enum TaskStatus {
  Open = 'open',
  Completed = 'completed',
  Archived = 'archived'
}

export interface Task {
  id: string;
  userId: string;
  title: string;
  description: string;
  dueDate: Date;
  status: TaskStatus;
  priority: TaskPriority;
  xpValue: number;
  category?: string;
  createdAt: Date;
}

export type CreateTaskInput = Omit<Task, 'id' | 'createdAt' | 'xpValue'>;
```

## Event Handlers

Always type event handlers properly:

```typescript
const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
  e.preventDefault();
  // Handle form submission
};

const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
  setFormData({ ...formData, [e.target.name]: e.target.value });
};

const handleClick = (e: React.MouseEvent<HTMLButtonElement>) => {
  // Handle click
};
```

## Component Organization

1. **Imports** - Group by type (React, external libs, internal)
2. **Types/Interfaces** - Define at top of file
3. **Component** - Main component function
4. **Helpers** - Helper functions at bottom
5. **Export** - Named export at end

```typescript
// 1. Imports
import { FC, useState, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { taskService } from '@/services/task.service';
import type { Task } from '@/types/task.types';

// 2. Types
interface TaskListProps {
  userId: string;
}

// 3. Component
export const TaskList: FC<TaskListProps> = ({ userId }) => {
  const [tasks, setTasks] = useState<Task[]>([]);
  
  useEffect(() => {
    loadTasks();
  }, [userId]);

  return (
    <div>
      {/* Component JSX */}
    </div>
  );
};

// 4. Helpers (if needed)
const sortTasks = (tasks: Task[]) => {
  return tasks.sort((a, b) => a.dueDate.getTime() - b.dueDate.getTime());
};
```

## Error Boundaries

Implement error boundaries for robust error handling:

```typescript
import { Component, ReactNode } from 'react';

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
}

interface State {
  hasError: boolean;
}

export class ErrorBoundary extends Component<Props, State> {
  state = { hasError: false };

  static getDerivedStateFromError() {
    return { hasError: true };
  }

  componentDidCatch(error: Error, errorInfo: any) {
    console.error('Error caught by boundary:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return this.props.fallback || <div>Something went wrong</div>;
    }

    return this.props.children;
  }
}
```

## Performance Optimization

### Memoization

Use `useMemo` and `useCallback` judiciously:

```typescript
const sortedTasks = useMemo(() => {
  return tasks.sort((a, b) => a.dueDate.getTime() - b.dueDate.getTime());
}, [tasks]);

const handleComplete = useCallback((taskId: string) => {
  completeTask(taskId);
}, [completeTask]);
```

### React.memo

Prevent unnecessary re-renders:

```typescript
export const TaskItem = React.memo<TaskItemProps>(({ task, onComplete }) => {
  return <div>{task.title}</div>;
});
```

## Best Practices

1. **Keep components small** - Single responsibility principle
2. **Extract logic to hooks** - Reusable, testable logic
3. **Avoid prop drilling** - Use Context for deeply nested props
4. **Handle loading states** - Show loaders during async operations
5. **Handle error states** - Display user-friendly error messages
6. **Accessibility** - Use semantic HTML, ARIA labels
7. **Keys in lists** - Always use stable, unique keys
8. **Avoid inline functions in JSX** - Define handlers outside JSX when possible
9. **Clean up effects** - Return cleanup functions from useEffect
10. **Type everything** - Leverage TypeScript for type safety

## Common Patterns for RPG Todo

### XP Progress Bar Component
```typescript
export const XPBar: FC<{ currentXP: number; nextLevelXP: number }> = ({ 
  currentXP, 
  nextLevelXP 
}) => {
  const progress = (currentXP / nextLevelXP) * 100;
  
  return (
    <div className="xp-bar">
      <div className="xp-bar-fill" style={{ width: `${progress}%` }} />
      <span className="xp-text">{currentXP} / {nextLevelXP} XP</span>
    </div>
  );
};
```

### Priority Color Mapping
```typescript
const priorityColors = {
  [TaskPriority.Low]: 'text-green-600',
  [TaskPriority.Medium]: 'text-yellow-600',
  [TaskPriority.High]: 'text-orange-600',
  [TaskPriority.Urgent]: 'text-red-600',
};
```
